accessible: false
author: Xavier Gillard
context: |
    A la page 777 du livre "Algorithms" 4th edition, on vous propose l'implémentation suivante de l'algorithme de Rabin Karp.

    .. code::

        public class RabinKarp {
          private String pat;      // the pattern  // needed only for Las Vegas
          private long patHash;    // pattern hash value
          private int m;           // pattern length
          private long q;          // a large prime, small enough to avoid long overflow
          private int R;           // radix
          private long RM;         // R^(M-1) % Q

          public RabinKarp(String pat) {
              this.pat = pat;      // save pattern (needed only for Las Vegas)
              R = 256;
              m = pat.length();
              q = longRandomPrime();

              // precompute R^(m-1) % q for use in removing leading digit
              RM = 1;
              for (int i = 1; i <= m-1; i++)
                  RM = (R * RM) % q;
              patHash = hash(pat, m);
          }

          // Compute hash for key[0..m-1].
          private long hash(String key, int m) {
              long h = 0;
              for (int j = 0; j < m; j++)
                  h = (R * h + key.charAt(j)) % q;
              return h;
          }

          // Monte Carlo
          private boolean check(int i) {
              return true;
          }

          // Returns the index of the first occurrrence of the pattern string in the text string.
          public int search(String txt) {
              int n = txt.length();
              if (n < m) return n;
              long txtHash = hash(txt, m);

              // check for match at offset 0
              if ((patHash == txtHash) && check(txt, 0))
                  return 0;

              // check for hash match; if hash match, check for exact match
              for (int i = m; i < n; i++) {
                  // Remove leading digit, add trailing digit, check for match.
                  txtHash = (txtHash + q - RM*txt.charAt(i-m) % q) % q;
                  txtHash = (txtHash*R + txt.charAt(i)) % q;

                  // match
                  int offset = i - m + 1;
                  if ((patHash == txtHash) && check(txt, offset))
                      return offset;
              }

              // no match
              return n;
          }


          // a random 31-bit prime
          private static long longRandomPrime() {
              BigInteger prime = BigInteger.probablePrime(31, new Random());
              return prime.longValue();
          }

        }
environment: python3
evaluate: best
groups: false
limits:
    memory: '100'
    output: '2'
    time: '30'
name: Pre-examen - Rabin Karp
network_grading: false
order: 25
problems:
    lasvegas_montecarlo:
        name: Parmi les affirmations ci-dessous, sélectionne celles qui sont correctes
        choices:
        -   text: La version ``Monte Carlo`` de la recherche de sous-chaine basée
                sur le finger printing de Rabin-Karp s'exécute en un temps linéaire
                et renvoie un résultat qui est très probablement correct.
            valid: true
        -   valid: true
            text: La version ``Las Vegas`` de la recherche de sous-chaine basée sur
                le finger printing de Rabin-Karp renvoie un résultat correct et s'exécute
                en un temps très probablement linéaire.
        -   text: La version ``Monte Carlo`` de la recherche de sous-chaine basée
                sur le finger printing de Rabin-Karp renvoie un résultat correct et
                s'exécute en un temps très probablement linéaire.
        -   text: La version ``Las Vegas`` de la recherche de sous-chaine basée sur
                le finger printing de Rabin-Karp s'exécute en un temps linéaire et
                renvoie un résultat qui est très probablement correct.
        type: multiple-choice
        header: ''
        limit: 0
        multiple: true
    nb_comparaisons:
        header: |+
            De combien de comparaisons a-t-on besoin pour rechercher la première occurence de la sous-chaine "SINF1121" dans le texte suivant si on applique l'algorithme de Rabin-Karp (variante Monte Carlo). Donnez un nombre unique.

            .. code::

                Je suis prêt pour mon examen de SINF1121, donc je vais le réussir.

        answer: '33'
        type: match
        name: ''
stored_submissions: 0
submission_limit:
    amount: 1
    period: -1
weight: 1.0
