accessible: true
author: Simon Hardy
context: |-
    Recall the FormalExpressionTree interface :

    .. code-block:: java

    /**
     * Un "FormalExpressionTree" est un arbre permettant de mémoriser
     * et de manipuler une expression analytique.
     *
     * Une classe implémentant cette interface doit disposer d'un CONSTRUCTEUR
     * prenant comme argument une chaîne de caractères (String) et construisant
     * l'arbre associé.
     * Cette chaîne est supposée correspondre à une expression analytique
     * syntaxiquement correcte et complètement parenthésée.
     * Une gestion d'exceptions doit être prévue lorsque cette précondition n'est pas vérifiée.
     *
     * Un CONSTRUCTEUR sans argument permet de construire un arbre élémentaire
     * correspondant à l'expression vide "".
     *
     */
    public interface FormalExpressionTree {
      /**
       * Cette méthode renvoie une chaîne de caractères correspondant à
       * l'expression analytique représentée dans l'arbre.
       *
       * @pre  this représente une expression analytique syntaxiquement correcte
       * @post une chaîne de caractères, correspondant à l'expression analytique
       *       complètement parenthésée représentée par this, est renvoyée.
       */
      public String toString();

      /**
       * Cette méthode calcule le nouvel arbre correspondant à la dérivée formelle
       * de l'arbre courant. L'arbre courant (this) n'est pas modifié.
       *
       * @pre   this représente une expression analytique syntaxiquement correcte.
       * @post  Une référence à un nouvel arbre représentant la dérivée formelle
       *        de this est renvoyée.
       */
      public FormalExpressionTree derive();
    }

        }

    You are asked to write unit tests (using JUnit) in order to check wether a particular implementation of this interface is correct.

    Here is a simple template you can use to write your tests :

    .. code-block:: java

        import org.junit.Test;
        import static org.junit.Assert.assertEquals;
        public class StackTests {

            String element = "a";
            MyStack<String> stack = new MyStack<String>();

            @Test
            public void firstTest() {
                stack.push(element);
                assertEquals(element,stack.pop());
            }

            @Test
            public void secondTest() {
                ...
            }
        }

    NB : you can (should?) also write tests for other types than String !
environment: java8scala
groups: true
limits:
    memory: '512'
    output: '100'
    time: '45'
name: Mission 1 - Unit tests for the stack [individual]
problems:
    stack_tests:
        name: Unit tests for the stack implementation
        type: code-file
        header: Upload your file here, with only one class named "StackTests". The
            class representing the stack under test is called *MyStack*, as written
            in the template !
        allowed_exts:
        - .java
weight: 1.0
