#!/usr/bin/env python

from subprocess import Popen, PIPE, STDOUT, check_output
from shutil import copyfile
from sys import exit
from inginious import feedback
from os import chdir

# Configuration des tests

countBuggyTests = 2
problemId = "stack_tests"
nameCorrectStack = "MyStack"
nameTestedStack = "MyStack"
nameBuggyStack = "MyBuggyStack"
nameTests = "StackTests"

buggyFeedbacks = [
    ""
]


def feedback_and_exit(problem_id, msg, result):
    feedback.set_global_result(result)
    feedback.set_global_feedback(msg)
    exit(1)


def save_input(problem_id, filename_save):
    problem_input = check_output(["getinput", problem_id])
    file_input = open(filename_save, "w")
    file_input.write(problem_input)
    file_input.close()


def compile_and_run():
    # We compile the stack implementation
    result = Popen(["javac", nameTestedStack + ".java"], stdout=PIPE, stderr=STDOUT)
    result.wait()

    if result.returncode != 0:
        feedback_and_exit(problemId, result.stdout.read(), "crash")

    # We compile the tests of the student
    result = Popen(["javac", "-cp", ".:junit-4.12.jar", nameTests + ".java"])
    result.wait()

    if result.returncode != 0:
        feedback_and_exit(problemId, result.stdout.read(), "crash")

    # We compile and run the tests
    result = Popen(
        [
            "run_student",
            "java",
            "-cp",
            ".:junit-4.12.jar:hamcrest-core-1.3.jar",
            "org.junit.runner.JUnitCore",
            nameTests
        ],
        stdout=PIPE,
        stderr=STDOUT
    )
    result.wait()

    if result.returncode == 252:
        feedback_and_exit(
            problemId,
            "Execution was killed because of an out-of-memory error",
            "overflow"
        )
    elif result.returncode == 253:
        feedback_and_exit(
            problemId,
            "Execution timed out",
            "timeout"
        )
    elif result.returncode == 254:
        feedback_and_exit(
            problemId,
            "Execution was killed because of a runtime error",
            "crash"
        )

    junit_result = result.stdout.read()

    passed = "OK" in junit_result
    return passed


# We retrieve the tests of the user
save_input(problemId, "student/" + nameTests + ".java")
copyfile("junit-4.12.jar", "student/junit-4.12.jar")
copyfile("hamcrest-core-1.3.jar", "student/hamcrest-core-1.3.jar")
copyfile("Stack.java", "student/Stack.java")
chdir("student/")

# We begin by the correct implementation
copyfile("../" + nameCorrectStack + ".java", nameTestedStack + ".java")
result = compile_and_run()

if not result:
    # The correct implementation failed
    feedback_and_exit(problemId, "You detected an error in a correct implementation", "failed")

#feedback_and_exit(problemId, "You passed the test", "success")

# We test the wrong implementations
countCorrectlyFail = 0

for i in range(1, countBuggyTests+1):
    filename = nameBuggyStack + str(i)
    copyfile("../" + filename + ".java", nameTestedStack + ".java")

    result = compile_and_run()

    if result:

        if i < len(buggyFeedbacks):
            feedback_msg = buggyFeedbacks[i]
            feedback.set_global_feedback(feedback_msg, True)
        # The tests should have caught an error in this implementation
        countCorrectlyFail += 1

# "1 +" is the correct implementation tested before
countCorrect = 1 + countCorrectlyFail
countTotal = 1 + countBuggyTests

grade = round(100 * (countCorrect / countTotal))
feedback.set_grade(grade)

if grade == 100:
    feedback_and_exit(problemId, "Congratulations, you passed the " + countTotal + " tests !", "success")
else:
    feedback_and_exit(
        problemId,
        "You detected errors in " + countCorrect + " out of " + countTotal + " incorrect implementations",
        "failed"
    )
