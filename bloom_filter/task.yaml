accessible: false
author: Xavier Gillard, Pierre Schaus
context: |-
    Les filtres de Bloom
    --------------------
    Un filtre de Bloom, est une structure de donnée très compacte et efficace qui permet d'implémenter un test d'appartenance rapide (:code:`.contains()`) à un très grand *ensemble*. Cependant, contrairement au test d'appartenance à un ensemble tel qu'implémenté à l'aide d'une HashMap, le test d'appartenance implémenté via un filtre de bloom peut renvoyer un résultat erroné (faux positifs possibles mais pas de faux négatifs) dans certains cas et cela, avec une faible probabilité.

    L'efficacité de cette structure, et le fait qu'elle ne requière qu'une quantité très faible (et constante !) de mémoire quel que soit le nombre d'éléments contenus dans l'ensemble en ont fait une structure de choix pour un très grand nombre d'applications. A titre d'exemple, on mentionnera le fait que les filtres de Bloom sont utilisés par certains devices réseaux pour faire du *Deep Packet Inspection*, ou encore que les bases de données *Google Big Table*, *Apache Cassandra* ou encore *Postgresql* utilisent cette structure de donnée afin de tester si une donnée se trouve en cache ou non.

    En effet la recherche de la donnée étant généralement coûteuse,
    un filtre de Bloom est utilisé pour éviter de faire une recherche
    si la donnée n'est pas présente. Par contre comme les erreurs de type faux-positifs sont possibles, le filtre de Bloom peut dire que la donnée s'y trouve alors que ça n'est pas vrai. Dans ce cas, il faudra effectuer la recherche pour vérifier et payer le coût de celle recherche (par exemple une recherche linéaire avec des accès
    sur le disque).

    Concrètement
    ------------
    Concrètement, un filtre de bloom consiste en un vecteur :math:`V = v_1..v_n` de bit et d'un ensemble :math:`F = f_1..f_k` de fonctions de hachage

    Pour ajouter un élément :math:`X` dans le set, on applique successivement chacune des fonctions :math:`f_i \in F` de hachage. L'application de chacune de ses fonctions à l'élément :math:`X` renvoie n nombre :math:`h_i \in \left[0..n\right]`. Pour marquer l'ajout de :math:`X` aufiltre de bloom, on sette simplement chacun des :math:`v_{h_i}` bits dans :math:`V`.

    De façon similaire, pour tester l'appartenance d'un élément :math:`X` au set, on vérifie que le :math:`h_i` ème bit :math:`\in V` correspondant à :math:`f_i(X)` est setté à `on`. Le test d'appartenance ne renverra `true` que ssi, cette condition est vérifiée pour chacune des :math:`f_i \in F`.

    Exemples
    ~~~~~~~~
    En supposant qu'on ait un filtre de Bloom représenté par 1 byte et 3 fonctions de hachage telles que:

    .. code::

        f1("Salut") = 0
        f2("Salut") = 1
        f3("Salut") = 2

        et

        f1("1121") = 0
        f2("1121") = 1
        f3("1121") = 4

    L'ajout de "Salut" au filtre 00000000 transforme celui-ci en 11100000. Si par la suite on veut tester que "Salut" est bien présent dans le filtre, on s'assure que les bits v1, v2 et v3 sont bien == 1.

    En continuant sur le même exemple, on voit que la chaine "1121" n'est pas présente dans la structure puisque le 4eme bit est 'off'.

    Autre exemple d'utilisation
    ---------------------------
    Outre le caching, les filtres de Bloom sont aussi utilisés pour donner une estimation du nombre d'éléments contenus dans un ensemble.

    On calcule cette estimation (:math:`n^*`) comme suit:
    :math:`n^* = -\frac{n}{k} ln \left( 1 - \frac{X}{n} \right)`

    avec n = la taille du filtre de Bloom, k = le nombre de fonctions de hachage différentes utilisées et X = le nombre des bits `on` dans le filtre.
environment: python3
evaluate: best
groups: false
limits:
    output: '2'
    time: '30'
    memory: '100'
name: Pré-examen - Bloom Filters
network_grading: false
problems:
    complexite_temp_ajout:
        choices:
        -   text: :math:`O(1)`
        -   text: :math:`\Omega(1)`
        -   text: :math:`\Theta(1)`
        -   text: :math:`O(n)`
        -   text: :math:`\Omega(n)`
        -   text: :math:`\Theta(n)`
        -   text: :math:`O(k)`
        -   text: :math:`\Omega(k)`
        -   text: :math:`\Theta(k)`
            valid: true
        -   text: On ne peut pas ajouter un élément à un filtre de Bloom.
        header: ''
        type: multiple-choice
        limit: 0
        name: Quelle est la complexité d'un ajout d'un élément dans le filtre de Bloom
            ?
    propositions:
        choices:
        -   text: Une HashMap stocke la valeur associée à chacune des clés.
            valid: true
        -   text: Un filtre de Bloom stocke la valeur associée à chacune des clés
        -   text: Malgré le risque de collision pour chacune des k fonctions de hachage,
                un filtre de Bloom permet de partager certains bits entre les clés
                associés à différents items car la probabilité de collision est réduite.
            valid: true
        -   text: Grâce au separate chaining, une HashMap peut partager certains bits
                entre différentes clés sans impacter la complexité d'un test d'appartenance.
        type: multiple-choice
        limit: 0
        header: ''
        name: 'Sélectionne les propositions qui sont vraies:'
        multiple: true
stored_submissions: 0
submission_limit:
    amount: -1
    period: -1
weight: 1.0
